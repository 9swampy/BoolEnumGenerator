namespace PrimS.BoolParameterGenerator;

using System;
using System.Linq;
using System.Text;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.Text;

[Generator]
public class BinaryStructGenerator() : BaseGenerator<BinaryStructSyntaxReceiver>(nameof(BinaryStructGenerator), nameof(GenerateBinaryStructAttribute))
{
  protected override string GenerateType(string structName, string namespaceName, string trueMember, string falseMember)
  {
    return $@"// <auto-generated>
namespace {namespaceName};

#nullable enable

using System;

public readonly struct {structName}
{{
    private readonly bool _value;

    public static {structName} {trueMember} {{ get; }} = new {structName}(true);

    public static {structName} {falseMember} {{ get; }} = new {structName}(false);

    private {structName}(bool value)
    {{
        _value = value;
    }}

    public static implicit operator bool({structName} boolEnum)
    {{
        return boolEnum._value;
    }}

    public static implicit operator {structName}(bool value) => value ? {trueMember} : {falseMember};

    public static bool operator ==({structName} left, {structName} right) => left._value == right._value;

    public static bool operator ==({structName} left, bool right) => left._value == right;

    public static bool operator ==(bool left, {structName} right) => left == right._value;

    public static bool operator !=({structName} left, {structName} right) => left._value != right._value;

    public static bool operator !=({structName} left, bool right) => left._value != right;

    public static bool operator !=(bool left, {structName} right) => left != right._value;

    public override bool Equals(object? obj) => obj is {structName} other && this == other;

    public override int GetHashCode() => _value.GetHashCode();

    public override string ToString()
    {{
        return _value.ToString();
    }}
}}";
  }

  protected override string GenerateAssertions(string name, string namespaceName, string trueMember, string falseMember)
  {
    return $@"// <auto-generated>
namespace {namespaceName};

using System;
using FluentAssertions.Execution;
using FluentAssertions.Primitives;
using FluentAssertions;

public class {name}Assertions : ReferenceTypeAssertions<{name}, {name}Assertions>
{{
    public {name}Assertions({name} instance) : base(instance) {{ }}

    protected override string Identifier => ""{name}"";

    public AndConstraint<{name}Assertions> BeTrue(string because = """", params object[] becauseArgs)
    {{
        Execute.Assertion
            .ForCondition(Subject == true)
            .BecauseOf(because, becauseArgs)
            .FailWith(""Expected {{context:{name}}} to be true but found {{0}}."", Subject);

        return new AndConstraint<{name}Assertions>(this);
    }}

    public AndConstraint<{name}Assertions> BeFalse(string because = """", params object[] becauseArgs)
    {{
        Execute.Assertion
            .ForCondition(Subject == false)
            .BecauseOf(because, becauseArgs)
            .FailWith(""Expected {{context:{name}}} to be false but found {{0}}."", Subject);

        return new AndConstraint<{name}Assertions>(this);
    }}

    public AndConstraint<{name}Assertions> NotBe({name} unexpected, string because = """", params object[] becauseArgs)
    {{
        return NotBe((bool)unexpected, because, becauseArgs);
    }}

    public AndConstraint<{name}Assertions> NotBe(bool unexpected, string because = """", params object[] becauseArgs)
    {{
        Execute.Assertion
            .ForCondition(Subject != unexpected)
            .BecauseOf(because, becauseArgs)
            .FailWith(""Expected {{context:{name}}} to not be {{0}} but found {{1}}."", unexpected, Subject);

        return new AndConstraint<{name}Assertions>(this);
    }}

    public AndConstraint<{name}Assertions> Be({name} expected, string because = """", params object[] becauseArgs)
    {{
        return Be((bool)expected, because, becauseArgs);
    }}

    public AndConstraint<{name}Assertions> Be(bool expected, string because = """", params object[] becauseArgs)
    {{
        Execute.Assertion
            .ForCondition(Subject == expected)
            .BecauseOf(because, becauseArgs)
            .FailWith(""Expected {{context:{name}}} to be {{0}} but found {{1}}."", expected, Subject);

        return new AndConstraint<{name}Assertions>(this);
    }}
}}";
  }

  protected override string GenerateExtensions(string name, string namespaceName)
  {
    return $@"// <auto-generated>
namespace FluentAssertions;

using System;
using FluentAssertions.Execution;
using FluentAssertions.Primitives;
using {namespaceName};

public static class {name}Extensions
{{
    public static {name}Assertions Should(this {name} instance)
    {{
        return new {name}Assertions(instance);
    }}
}}";
  }

  private static string GenerateTests(string name, string namespaceName, string trueMember, string falseMember)
  {
    var camelCaseName = ToCamelCase(name);
    return $@"
namespace {namespaceName}
{{
  using Xunit;
  using FluentAssertions;
  using {namespaceName};

  public class {name}Tests
  {{
    [Fact]
    public void Given{name}{trueMember}ShouldBeTrue()
    {{
        var {camelCaseName} = {name}.{trueMember};
        {camelCaseName}.Should().BeTrue();
    }}

    [Fact]
    public void Given{name}FalseShouldBeFalse()
    {{
        var {camelCaseName} = {name}.{falseMember};
        {camelCaseName}.Should().BeFalse();
    }}

    [Fact]
    public void Given{name}TrueWhenCastBoolShouldBeTrue()
    {{
        var {camelCaseName} = {name}.{trueMember};
        ((bool){camelCaseName}).Should().BeTrue();
    }}

    [Fact]
    public void Given{name}{falseMember}WhenCastBoolShouldBeFalse()
    {{
        var {camelCaseName} = {name}.{falseMember};
        ((bool){camelCaseName}).Should().BeFalse();
    }}

    [Fact]
    public void Given{name}{trueMember}ShouldBe{name}{trueMember}()
    {{
        var {camelCaseName} = {name}.{trueMember};
        {camelCaseName}.Should().Be({name}.{trueMember});
    }}

    [Fact]
    public void Given{name}{falseMember}ShouldBe{name}{falseMember}()
    {{
        var {camelCaseName} = {name}.{falseMember};
        {camelCaseName}.Should().Be({name}.{falseMember});
    }}

    [Fact]
    public void Given{name}{trueMember}ShouldBeBoolTrue()
    {{
        var {camelCaseName} = {name}.{trueMember};
        {camelCaseName}.Should().Be(true);
    }}

    [Fact]
    public void Given{name}FalseShouldBeBoolFalse()
    {{
        var {camelCaseName} = {name}.{falseMember};
        {camelCaseName}.Should().Be(false);
    }}

    [Fact]
    public void Given{name}{trueMember}ShouldNotBeFalse()
    {{
        var {camelCaseName} = {name}.{trueMember};
        {camelCaseName}.Should().NotBe(false);
    }}

    [Fact]
    public void Given{name}{trueMember}ShouldNotBe{name}False()
    {{
        var {camelCaseName} = {name}.{trueMember};
        {camelCaseName}.Should().NotBe({name}.{falseMember});
    }}

    [Fact]
    public void ShouldCtor()
    {{
      var {camelCaseName} = new {name}();

      {camelCaseName}.Should().NotBeNull();
    }}

    [Fact]
    public void GivenBoolFalseWhenImplicitAssignShouldBeFalse()
    {{
      {name} {camelCaseName} = false;

      {camelCaseName}.Should().BeFalse();
    }}

    [Fact]
    public void GivenBoolTrueWhenImplicitAssignShouldBeTrue()
    {{
      {name} {camelCaseName} = true;

      {camelCaseName}.Should().BeTrue();
    }}

    [Fact]
    public void GivenBoolFalseWhenImplicitAssign{name}ParameterShouldBeFalse()
    {{
      {name} {camelCaseName} = false;

      {name}Parameter({camelCaseName}).Should().BeFalse();
    }}

    [Fact]
    public void GivenBoolTrueWhenImplicitAssign{name}ParameterShouldBeTrue()
    {{
      {name} {camelCaseName} = true;

      {name}Parameter({camelCaseName}).Should().BeTrue();
    }}

    [Fact]
    public void GivenBoolFalseWhenImplicitAssignIsBoolParameterShouldBeFalse()
    {{
      IsBoolParameter(false).Should().BeFalse();
    }}

    [Fact]
    public void GivenBoolFalseWhenImplicitAssignIsBoolParameterShouldBe{name}{falseMember}()
    {{
      false.Should().Be({name}.{falseMember});
      IsBoolParameter(false).Should().Be({name}.{falseMember});
    }}

    [Fact]
    public void GivenBoolFalseWhenImplicitAssignIsBoolParameterShouldBeTrue()
    {{
      IsBoolParameter(true).Should().BeTrue();
    }}

    [Fact]
    public void GivenBoolTrueWhenImplicitAssignIsBoolParameterShouldBe{name}True()
    {{
      true.Should().Be({name}.{trueMember});
      IsBoolParameter(true).Should().Be({name}.{trueMember});
    }}

    [Fact]
    public void GivenBoolTrueShouldEqual{name}()
    {{
      ({name}.{trueMember} == true).Should().BeTrue();
    }}

    [Fact]
    public void GivenBoolFalseShouldEqual{name}()
    {{
      ({name}.{falseMember} == false).Should().BeTrue();
    }}

    [Fact]
    public void GivenBoolTrueShouldNotEqualOpposite{camelCaseName}()
    {{
      ({name}.{trueMember} == false).Should().BeFalse();
    }}

    [Fact]
    public void GivenBoolFalseShouldNotEqualOpposite{name}()
    {{
      ({name}.{falseMember} == true).Should().BeFalse();
    }}

    private static {name} IsBoolParameter(bool value)
    {{
      return value;
    }}

    private static bool {name}Parameter({name} value)
    {{
      return value;
    }}
  }}
}}";
  }

  private static string ToCamelCase(string input)
  {
    if (string.IsNullOrEmpty(input) || !char.IsUpper(input[0]))
    {
      return input;
    }

    char[] chars = input.ToCharArray();
    for (int i = 0; i < chars.Length; i++)
    {
      if (i == 0 || (i > 0 && char.IsUpper(chars[i]) && !char.IsUpper(chars[i - 1])))
      {
        chars[i] = char.ToLower(chars[i]);
      }
      else
      {
        break;
      }
    }

    return new string(chars);
  }
}